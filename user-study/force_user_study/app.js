const SUBMIT_ENDPOINT = "https://script.google.com/macros/s/AKfycbxI1aANYAPYoRK8HDogZgrNpQ0byPtwWykVaPeaHmJLH60ebzfbXwvDJRfZh9ERGikn/exec";
const MANIFEST_PATH = "manifest.json";
const STORAGE_KEY = "force_user_study_participant_id";
const LABELS = ["A", "B", "C", "D"];
const CONDITION_ORDER = ["wind", "point", "wind_change", "point_change"];

const appEl = document.getElementById("app");
const statusEl = document.getElementById("status");

const state = {
  participantId: getOrCreateParticipantId(),
  manifest: null,
  selectedCondition: "all",
  questions: [],
  index: 0,
  answersByQuestion: {}
};

boot();

async function boot() {
  setStatus(`Participant ID: ${state.participantId}`, false);
  try {
    const manifest = await loadManifest();
    state.manifest = manifest;
    renderIntro();
  } catch (err) {
    setStatus(err.message, true);
    renderManifestError(err.message);
  }
}

function getOrCreateParticipantId() {
  const stored = localStorage.getItem(STORAGE_KEY);
  if (stored) {
    return stored;
  }
  let id = "";
  if (window.crypto && typeof window.crypto.randomUUID === "function") {
    id = window.crypto.randomUUID();
  } else {
    id = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.floor(Math.random() * 16);
      const v = c === "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
  localStorage.setItem(STORAGE_KEY, id);
  return id;
}

async function loadManifest() {
  const res = await fetch(MANIFEST_PATH, { cache: "no-store" });
  if (!res.ok) {
    throw new Error(
      "Could not load user_study/manifest.json. Run the build script first and refresh this page."
    );
  }
  const data = await res.json();
  if (!data.conditions || typeof data.conditions !== "object") {
    throw new Error("Manifest format is invalid: missing 'conditions'.");
  }
  return data;
}

function renderManifestError(msg) {
  appEl.innerHTML = "";
  const block = document.createElement("div");
  block.innerHTML = `
    <h2>Manifest Not Available</h2>
    <p>${escapeHtml(msg)}</p>
    <p class="notice">Expected file: <code>user_study/manifest.json</code></p>
    <div class="controls">
      <button id="retry" class="secondary">Retry</button>
    </div>
  `;
  appEl.appendChild(block);
  document.getElementById("retry").addEventListener("click", () => boot());
}

function renderIntro() {
  appEl.innerHTML = `
    <h2>User Study: Evaluation of Force-Controllable Video Generation</h2>
    <p>Thank you for participating in this study.</p>
    <p>
      We are conducting a user study to evaluate the quality of videos generated by our Force-Controllable Video Generation model. Your feedback will help us better understand how effectively the model produces videos that adhere to input force conditions, respect real-world physics, and maintain overall visual quality.
    </p>
    <p>In this study, you will evaluate videos based on three criteria:</p>
    <ol>
      <li><strong>Force Adherence</strong><br>How well do the motions in the video follow the specified input force conditions (indicated by arrows shown in the video)?</li>
      <li><strong>Physics Awareness</strong><br>How consistent are the motions with real-world physical laws and intuitive physical behavior?</li>
      <li><strong>Visual Quality</strong><br>How visually realistic and overall high-quality is the video?</li>
    </ol>
    <p>
      For each question, you will be shown 3 or 4 videos generated under the same force condition. For each of the three criteria above, please select the video that best satisfies the criterion. If none of the videos are satisfactory, you may choose \"None / All are poor.\"
    </p>
    <p><strong>Estimated time:</strong> approximately 15-20 minutes to complete.</p>
    <p>All responses are anonymous and will be used solely for research purposes.</p>
    <p>Thank you for your time and valuable contribution.</p>

    <div class="controls">
      <button id="start-study">I Consent, Start Study</button>
    </div>
  `;

  document.getElementById("start-study").addEventListener("click", () => {
    state.selectedCondition = "all";
    startStudy();
  });
}

function getAvailableConditionOptions() {
  const available = CONDITION_ORDER.filter((name) => state.manifest.conditions[name]);
  const opts = [{ value: "all", label: "All conditions" }];
  for (const c of available) {
    opts.push({ value: c, label: humanCondition(c) });
  }
  return opts;
}

function startStudy() {
  state.questions = buildQuestions();
  state.answersByQuestion = {};
  state.index = 0;

  if (state.questions.length === 0) {
    appEl.innerHTML = `
      <h2>No Questions Available</h2>
      <p class="notice">The selected condition set has no valid cases in the manifest.</p>
      <div class="controls"><button id="back" class="secondary">Back</button></div>
    `;
    document.getElementById("back").addEventListener("click", () => renderIntro());
    return;
  }
  renderQuestion();
}

function buildQuestions() {
  const selectedConditions =
    state.selectedCondition === "all"
      ? CONDITION_ORDER.filter((c) => state.manifest.conditions[c])
      : [state.selectedCondition];

  const items = [];
  for (const condition of selectedConditions) {
    const conditionData = state.manifest.conditions[condition];
    if (!conditionData || !Array.isArray(conditionData.cases) || !Array.isArray(conditionData.methods)) {
      continue;
    }

    for (const caseItem of conditionData.cases) {
      const shuffledMethods = shuffleArray(conditionData.methods.slice());
      const videos = {};
      for (const method of conditionData.methods) {
        videos[method] = caseItem.videos[method];
      }

      items.push({
        condition,
        caseId: caseItem.id,
        shownOrder: shuffledMethods,
        videos
      });
    }
  }
  return items;
}

function renderQuestion() {
  const q = state.questions[state.index];
  const answer =
    state.answersByQuestion[state.index] || {
      force: "",
      physics: "",
      visual: ""
    };
  state.answersByQuestion[state.index] = answer;

  const hasArrowlessVideo = q.shownOrder.some((method) => method === "kling_motion_brush");

  const cards = q.shownOrder
    .map((method, idx) => {
      const label = LABELS[idx];
      const src = q.videos[method];
      return `
      <div class="video-card">
        <div class="video-label">${label}</div>
        <video controls muted preload="metadata" playsinline autoplay loop>
          <source src="${encodeURI(src)}" type="video/mp4">
          Your browser does not support MP4 playback.
        </video>
      </div>`;
    })
    .join("");

  const choiceValues = LABELS.slice(0, q.shownOrder.length).concat(["NONE"]);

  const gridClass = q.shownOrder.length === 4 ? "video-grid four-grid" : "video-grid";

  appEl.innerHTML = `
    <div class="progress">
      <span>Question ${state.index + 1}/${state.questions.length}</span>
      <span>${humanCondition(q.condition)}</span>
    </div>

    <p><strong>Case:</strong> ${escapeHtml(q.caseId)}</p>
    ${
      hasArrowlessVideo
        ? '<p class="notice arrow-note"><strong>Important:</strong> If one video has no arrows, evaluate it using the <strong>same target force input</strong> indicated by arrows in the other videos for this question.</p>'
        : ""
    }
    <div class="${gridClass}">${cards}</div>

    ${renderPromptBlock(
      "force",
      "1) Force adherence: Which video best follows the force condition?",
      choiceValues,
      answer.force
    )}

    ${renderPromptBlock(
      "physics",
      "2) Physics awareness: Which video is most physically plausible?",
      choiceValues,
      answer.physics
    )}

    ${renderPromptBlock(
      "visual",
      "3) Visual quality: Which video looks best overall?",
      choiceValues,
      answer.visual
    )}

    <div class="controls">
      <button id="prev" class="secondary" ${state.index === 0 ? "disabled" : ""}>Previous</button>
      <button id="next" ${isQuestionComplete(answer) ? "" : "disabled"}>${
        state.index === state.questions.length - 1 ? "Submit" : "Next"
      }</button>
    </div>
    <p class="notice">Method identities are hidden. Labels A/B/C/D are randomized per question.</p>
  `;

  ["force", "physics", "visual"].forEach((name) => {
    const radios = appEl.querySelectorAll(`input[name="${name}"]`);
    radios.forEach((radio) => {
      radio.addEventListener("change", (evt) => {
        const existing = state.answersByQuestion[state.index] || {};
        state.answersByQuestion[state.index] = {
          force: existing.force || "",
          physics: existing.physics || "",
          visual: existing.visual || "",
          [name]: evt.target.value
        };
        syncNextButtonState();
      });
    });
  });

  playVisibleVideos();

  document.getElementById("prev").addEventListener("click", () => {
    if (state.index > 0) {
      state.index -= 1;
      renderQuestion();
    }
  });

  document.getElementById("next").addEventListener("click", async () => {
    const currentAnswer = state.answersByQuestion[state.index];
    if (!isQuestionComplete(currentAnswer)) {
      return;
    }

    if (state.index === state.questions.length - 1) {
      await finishStudy();
      return;
    }

    state.index += 1;
    renderQuestion();
  });
}

function renderPromptBlock(name, prompt, choices, selectedValue) {
  const options = choices
    .map((value) => {
      const checked = value === selectedValue ? "checked" : "";
      const label = value === "NONE" ? "None (all are bad)" : value;
      return `
      <label class="radio-line">
        <input type="radio" name="${name}" value="${value}" ${checked}>
        ${escapeHtml(label)}
      </label>`;
    })
    .join("");

  return `
    <fieldset class="fieldset">
      <legend>${escapeHtml(prompt)}</legend>
      ${options}
    </fieldset>
  `;
}

function syncNextButtonState() {
  const nextBtn = document.getElementById("next");
  if (!nextBtn) {
    return;
  }
  nextBtn.disabled = !isQuestionComplete(state.answersByQuestion[state.index]);
}

function playVisibleVideos() {
  const videos = appEl.querySelectorAll("video");
  videos.forEach((video) => {
    const playPromise = video.play();
    if (playPromise && typeof playPromise.catch === "function") {
      playPromise.catch(() => {});
    }
  });
}

function isQuestionComplete(answer) {
  return !!(answer && answer.force && answer.physics && answer.visual);
}

async function finishStudy() {
  const now = new Date().toISOString();
  const responses = state.questions.map((q, idx) => {
    const answer = state.answersByQuestion[idx] || {};
    return {
      participant_id: state.participantId,
      condition: q.condition,
      case_id: q.caseId,
      shown_order: q.shownOrder,
      answers: {
        force: answer.force,
        physics: answer.physics,
        visual: answer.visual
      },
      timestamp_iso: now,
      user_agent: navigator.userAgent
    };
  });

  const payload = {
    participant_id: state.participantId,
    completed_at_iso: now,
    user_agent: navigator.userAgent,
    responses
  };

  let postResult = null;
  if (SUBMIT_ENDPOINT.trim()) {
    postResult = await trySubmitOnline(payload);
  }

  let downloaded = false;
  if (!postResult || !postResult.ok) {
    downloadJson(payload, `user_study_${state.participantId.slice(0, 8)}.json`);
    downloaded = true;
  }

  renderComplete(postResult, downloaded);
}

async function trySubmitOnline(payload) {
  try {
    const res = await fetch(SUBMIT_ENDPOINT, {
      method: "POST",
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      return {
        ok: false,
        message: `Server returned status ${res.status}.`
      };
    }

    return {
      ok: true,
      message: "Submission uploaded successfully."
    };
  } catch (err) {
    return {
      ok: false,
      message: err && err.message ? err.message : "Upload failed due to a network error."
    };
  }
}

function renderComplete(postResult, downloaded) {
  const completionCode = state.participantId.replace(/-/g, "").slice(0, 8).toUpperCase();

  let message = "Responses saved locally as a downloaded JSON file.";
  if (postResult && postResult.ok) {
    message = "Responses submitted online successfully.";
  }

  let fallback = "";
  if (postResult && !postResult.ok) {
    fallback = `<p class="notice">Online submit failed: ${escapeHtml(postResult.message)} Local JSON fallback was used.</p>`;
  }

  const downloadNote = downloaded
    ? '<p class="notice">A JSON copy was downloaded to your device.</p>'
    : "";

  appEl.innerHTML = `
    <h2>Study Complete</h2>
    <p>${escapeHtml(message)}</p>
    ${fallback}
    ${downloadNote}
    <p>Your completion code:</p>
    <div class="completion-code">${completionCode}</div>
  `;
}

function downloadJson(data, filename) {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function setStatus(text, isError) {
  statusEl.textContent = text;
  statusEl.className = isError ? "status error" : "status";
}

function shuffleArray(arr) {
  for (let i = arr.length - 1; i > 0; i -= 1) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function humanCondition(condition) {
  switch (condition) {
    case "wind":
      return "Wind";
    case "point":
      return "Point";
    case "wind_change":
      return "Wind (Change)";
    case "point_change":
      return "Point (Change)";
    default:
      return condition;
  }
}

function escapeHtml(value) {
  return String(value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/\"/g, "&quot;")
    .replace(/'/g, "&#39;");
}
