const SUBMIT_ENDPOINT = "https://script.google.com/macros/s/AKfycbxI1aANYAPYoRK8HDogZgrNpQ0byPtwWykVaPeaHmJLH60ebzfbXwvDJRfZh9ERGikn/exec";
const MANIFEST_PATH = "manifest.json";
const STORAGE_KEY = "force_user_study_participant_id";
const LABELS = ["A", "B", "C", "D"];
const CONDITION_ORDER = ["wind", "point", "wind_change", "point_change"];
const DEBUG_CONDITION_ONLY = ""; // Set to "" to disable debug restriction.

const appEl = document.getElementById("app");
const statusEl = document.getElementById("status");

const state = {
  participantId: getOrCreateParticipantId(),
  manifest: null,
  selectedCondition: "all",
  questions: [],
  index: 0,
  answersByQuestion: {},
  isSubmitting: false
};

boot();

async function boot() {
  setStatus(`Participant ID: ${state.participantId}`, false);
  try {
    const manifest = await loadManifest();
    state.manifest = manifest;
    renderIntro();
  } catch (err) {
    setStatus(err.message, true);
    renderManifestError(err.message);
  }
}

function getOrCreateParticipantId() {
  const stored = localStorage.getItem(STORAGE_KEY);
  if (stored) {
    return stored;
  }
  let id = "";
  if (window.crypto && typeof window.crypto.randomUUID === "function") {
    id = window.crypto.randomUUID();
  } else {
    id = "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
      const r = Math.floor(Math.random() * 16);
      const v = c === "x" ? r : (r & 0x3) | 0x8;
      return v.toString(16);
    });
  }
  localStorage.setItem(STORAGE_KEY, id);
  return id;
}

async function loadManifest() {
  const res = await fetch(MANIFEST_PATH, { cache: "no-store" });
  if (!res.ok) {
    throw new Error(
      "Could not load user_study/manifest.json. Run the build script first and refresh this page."
    );
  }
  const data = await res.json();
  if (!data.conditions || typeof data.conditions !== "object") {
    throw new Error("Manifest format is invalid: missing 'conditions'.");
  }
  return data;
}

function renderManifestError(msg) {
  appEl.innerHTML = "";
  const block = document.createElement("div");
  block.innerHTML = `
    <h2>Manifest Not Available</h2>
    <p>${escapeHtml(msg)}</p>
    <p class="notice">Expected file: <code>user_study/manifest.json</code></p>
    ${renderArrowGuide()}
    <div class="controls">
      <button id="retry" class="secondary">Retry</button>
    </div>
  `;
  appEl.appendChild(block);
  document.getElementById("retry").addEventListener("click", () => boot());
}

function renderIntro() {
  appEl.innerHTML = `
    <h2>User Study: Evaluation of Force-Controllable Video Generation</h2>
    <p>Thank you for participating in this study.</p>
    <p>
      We are conducting a user study to evaluate the quality of videos generated by our Force-Controllable Video Generation model. Your feedback will help us better understand how effectively the model produces videos that adhere to input force conditions, respect real-world physics, and maintain overall visual quality.
    </p>
    <p>In this study, you will evaluate videos based on three criteria:</p>
    <ol>
      <li><strong>Force Adherence</strong><br>How well do the motions in the video follow the specified input force conditions (indicated by arrows shown in the video)?</li>
      <li><strong>Physics Awareness</strong><br>How consistent are the motions with real-world physical laws and intuitive physical behavior?</li>
      <li><strong>Visual Quality</strong><br>How visually realistic and overall high-quality is the video?</li>
    </ol>
    <p>
      For each question, you will be shown 3 or 4 videos generated under the same force condition. For each criterion, you may select one or more videos that satisfy the metric. If none are satisfactory, choose \"None / All are poor\" only.
    </p>
    <p><strong>Estimated time:</strong> approximately 20-25 minutes to complete.</p>
    <p>All responses are anonymous and will be used solely for research purposes.</p>
    <p>Thank you for your time and valuable contribution.</p>
    ${renderArrowGuide()}

    <div class="controls">
      <button id="start-study">I Consent, Start Study</button>
    </div>
  `;

  document.getElementById("start-study").addEventListener("click", () => {
    state.selectedCondition = "all";
    startStudy();
  });
}

function getAvailableConditionOptions() {
  const available = CONDITION_ORDER.filter((name) => state.manifest.conditions[name]);
  const opts = [{ value: "all", label: "All conditions" }];
  for (const c of available) {
    opts.push({ value: c, label: humanCondition(c) });
  }
  return opts;
}

function startStudy() {
  if (DEBUG_CONDITION_ONLY && CONDITION_ORDER.includes(DEBUG_CONDITION_ONLY)) {
    state.selectedCondition = DEBUG_CONDITION_ONLY;
  }
  state.questions = buildQuestions();
  state.answersByQuestion = {};
  state.index = 0;

  if (state.questions.length === 0) {
    appEl.innerHTML = `
      <h2>No Questions Available</h2>
      <p class="notice">The selected condition set has no valid cases in the manifest.</p>
      ${renderArrowGuide()}
      <div class="controls"><button id="back" class="secondary">Back</button></div>
    `;
    document.getElementById("back").addEventListener("click", () => renderIntro());
    return;
  }
  renderQuestion();
}

function buildQuestions() {
  let selectedConditions =
    state.selectedCondition === "all"
      ? CONDITION_ORDER.filter((c) => state.manifest.conditions[c])
      : [state.selectedCondition];

  if (DEBUG_CONDITION_ONLY && CONDITION_ORDER.includes(DEBUG_CONDITION_ONLY)) {
    selectedConditions = selectedConditions.filter((c) => c === DEBUG_CONDITION_ONLY);
  }

  const items = [];
  for (const condition of selectedConditions) {
    const conditionData = state.manifest.conditions[condition];
    if (!conditionData || !Array.isArray(conditionData.cases) || !Array.isArray(conditionData.methods)) {
      continue;
    }

    for (const caseItem of conditionData.cases) {
      const shuffledMethods = shuffleArray(conditionData.methods.slice());
      const videos = {};
      for (const method of conditionData.methods) {
        videos[method] = caseItem.videos[method];
      }

      items.push({
        condition,
        caseId: caseItem.id,
        shownOrder: shuffledMethods,
        videos
      });
    }
  }
  return items;
}

function renderQuestion() {
  scrollToTop();
  const q = state.questions[state.index];
  const answer =
    state.answersByQuestion[state.index] || {
      force: [],
      physics: [],
      visual: []
    };
  answer.force = normalizeAnswerList(answer.force);
  answer.physics = normalizeAnswerList(answer.physics);
  answer.visual = normalizeAnswerList(answer.visual);
  state.answersByQuestion[state.index] = answer;

  const hasArrowlessVideo = q.shownOrder.some((method) => method === "kling_motion_brush");

  const cards = q.shownOrder
    .map((method, idx) => {
      const label = LABELS[idx];
      const src = q.videos[method];
      return `
      <div class="video-card">
        <div class="video-label">${label}</div>
        <video controls muted preload="metadata" playsinline autoplay loop>
          <source src="${encodeURI(src)}" type="video/mp4">
          Your browser does not support MP4 playback.
        </video>
      </div>`;
    })
    .join("");

  const choiceValues = LABELS.slice(0, q.shownOrder.length).concat(["NONE"]);
  const referenceImageCandidates = buildReferenceImageCandidates(q.condition, q.caseId);

  const gridClass = q.shownOrder.length === 4 ? "video-grid four-grid" : "video-grid";

  appEl.innerHTML = `
    <div class="progress">
      <span>Question ${state.index + 1}/${state.questions.length}</span>
      <span>${humanCondition(q.condition)}</span>
    </div>

    <p><strong>Case:</strong> ${escapeHtml(q.caseId)}</p>
    ${renderArrowGuide(q.condition)}
    ${
      hasArrowlessVideo
        ? '<p class="notice arrow-note"><strong>Important:</strong> If one video has no arrows, evaluate it using the <strong>same target force input</strong> indicated by arrows in the other videos for this question.</p>'
        : ""
    }
    ${renderReferenceImage(referenceImageCandidates[0])}
    <div class="${gridClass}">${cards}</div>

    ${renderPromptBlock(
      "force",
      "1) Force adherence: Which video(s) satisfy this metric?",
      "How well do the motions in the video follow the specified input force conditions (indicated by arrows shown in the video)?",
      choiceValues,
      answer.force
    )}

    ${renderPromptBlock(
      "physics",
      "2) Physics awareness: Which video(s) satisfy this metric?",
      "How consistent are the motions with real-world physical laws and intuitive physical behavior?",
      choiceValues,
      answer.physics
    )}

    ${renderPromptBlock(
      "visual",
      "3) Visual quality: Which video(s) satisfy this metric?",
      "How visually realistic and overall high-quality is the video?",
      choiceValues,
      answer.visual
    )}

    <div class="controls">
      <button id="prev" class="secondary" ${state.index === 0 ? "disabled" : ""}>Previous</button>
      <button id="next" ${isQuestionComplete(answer) ? "" : "disabled"}>${
        state.index === state.questions.length - 1 ? "Submit" : "Next"
      }</button>
    </div>
    <p class="notice">Method identities are hidden. Labels A/B/C/D are randomized per question.</p>
  `;
  setupReferenceImageFallback(referenceImageCandidates);

  ["force", "physics", "visual"].forEach((name) => {
    const inputs = appEl.querySelectorAll(`input[name="${name}"]`);
    inputs.forEach((input) => {
      input.addEventListener("change", (evt) => {
        const existing = state.answersByQuestion[state.index] || {};
        const currentValues = normalizeAnswerList(existing[name]);
        const value = evt.target.value;
        const checked = evt.target.checked;
        const nextValues = computeNextValues(currentValues, value, checked);

        state.answersByQuestion[state.index] = {
          force: normalizeAnswerList(existing.force),
          physics: normalizeAnswerList(existing.physics),
          visual: normalizeAnswerList(existing.visual),
          [name]: nextValues
        };
        syncChoiceInputs(name, nextValues);
        syncNextButtonState();
      });
    });
  });

  playVisibleVideos();

  document.getElementById("prev").addEventListener("click", () => {
    if (state.index > 0) {
      state.index -= 1;
      renderQuestion();
    }
  });

  document.getElementById("next").addEventListener("click", async () => {
    if (state.isSubmitting) {
      return;
    }

    const currentAnswer = state.answersByQuestion[state.index];
    if (!isQuestionComplete(currentAnswer)) {
      return;
    }

    if (state.index === state.questions.length - 1) {
      const nextBtn = document.getElementById("next");
      if (nextBtn) {
        nextBtn.disabled = true;
        nextBtn.textContent = "Submitting...";
      }
      await finishStudy();
      return;
    }

    state.index += 1;
    renderQuestion();
  });
}

function renderPromptBlock(name, prompt, description, choices, selectedValue) {
  const selectedValues = normalizeAnswerList(selectedValue);
  const options = choices
    .map((value) => {
      const checked = selectedValues.includes(value) ? "checked" : "";
      const label = value === "NONE" ? "None (all are bad)" : value;
      return `
      <label class="radio-line">
        <input type="checkbox" name="${name}" value="${value}" ${checked}>
        ${escapeHtml(label)}
      </label>`;
    })
    .join("");

  return `
    <fieldset class="fieldset">
      <legend>${escapeHtml(prompt)} (select one or more; NONE is exclusive)</legend>
      <p class="metric-description">${escapeHtml(description)}</p>
      ${options}
    </fieldset>
  `;
}

function syncNextButtonState() {
  const nextBtn = document.getElementById("next");
  if (!nextBtn) {
    return;
  }
  nextBtn.disabled = !isQuestionComplete(state.answersByQuestion[state.index]);
}

function playVisibleVideos() {
  const videos = appEl.querySelectorAll("video");
  videos.forEach((video) => {
    const playPromise = video.play();
    if (playPromise && typeof playPromise.catch === "function") {
      playPromise.catch(() => {});
    }
  });
}

function isQuestionComplete(answer) {
  return Boolean(
    answer &&
      normalizeAnswerList(answer.force).length > 0 &&
      normalizeAnswerList(answer.physics).length > 0 &&
      normalizeAnswerList(answer.visual).length > 0,
  );
}

async function finishStudy() {
  if (state.isSubmitting) {
    return;
  }
  state.isSubmitting = true;

  const now = new Date().toISOString();
  const responses = state.questions.map((q, idx) => {
    const answer = state.answersByQuestion[idx] || {};
    const forceChoices = normalizeAnswerList(answer.force);
    const physicsChoices = normalizeAnswerList(answer.physics);
    const visualChoices = normalizeAnswerList(answer.visual);
    return {
      participant_id: state.participantId,
      condition: q.condition,
      case_id: q.caseId,
      shown_order: q.shownOrder,
      answers: {
        force: forceChoices[0] || "",
        physics: physicsChoices[0] || "",
        visual: visualChoices[0] || ""
      },
      answers_multi: {
        force: forceChoices,
        physics: physicsChoices,
        visual: visualChoices
      },
      timestamp_iso: now,
      user_agent: navigator.userAgent
    };
  });

  const payload = {
    participant_id: state.participantId,
    completed_at_iso: now,
    user_agent: navigator.userAgent,
    responses
  };

  try {
    let postResult = null;
    if (SUBMIT_ENDPOINT.trim()) {
      postResult = await trySubmitOnline(payload);
    }

    let downloaded = false;
    if (!postResult || !postResult.ok) {
      downloadJson(payload, `user_study_${state.participantId.slice(0, 8)}.json`);
      downloaded = true;
    }

    renderComplete(postResult, downloaded);
  } finally {
    state.isSubmitting = false;
  }
}

async function trySubmitOnline(payload) {
  try {
    const res = await fetch(SUBMIT_ENDPOINT, {
      method: "POST",
      body: JSON.stringify(payload)
    });

    if (!res.ok) {
      return {
        ok: false,
        message: `Server returned status ${res.status}.`
      };
    }

    return {
      ok: true,
      message: "Submission uploaded successfully."
    };
  } catch (err) {
    return {
      ok: false,
      message: err && err.message ? err.message : "Upload failed due to a network error."
    };
  }
}

function renderComplete(postResult, downloaded) {
  scrollToTop();
  const completionCode = state.participantId.replace(/-/g, "").slice(0, 8).toUpperCase();

  let message = "Responses saved locally as a downloaded JSON file.";
  if (postResult && postResult.ok) {
    message = "Responses submitted online successfully.";
  }

  let fallback = "";
  if (postResult && !postResult.ok) {
    fallback = `<p class="notice">Online submit failed: ${escapeHtml(postResult.message)} Local JSON fallback was used.</p>`;
  }

  const downloadNote = downloaded
    ? '<p class="notice">A JSON copy was downloaded to your device.</p>'
    : "";

  appEl.innerHTML = `
    <h2>Study Complete</h2>
    <p>${escapeHtml(message)}</p>
    ${fallback}
    ${downloadNote}
    <p>Thank you for completing the user study. Your participation and feedback are highly valuable to our research.</p>
    <p>Your completion code:</p>
    <div class="completion-code">${completionCode}</div>
  `;
}

function downloadJson(data, filename) {
  const blob = new Blob([JSON.stringify(data, null, 2)], { type: "application/json" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
}

function setStatus(text, isError) {
  statusEl.textContent = text;
  statusEl.className = isError ? "status error" : "status";
}

function buildReferenceImageCandidates(condition, caseId) {
  const base = String(caseId || "").replace(/\.[^.]+$/, "");
  return [
    `imgs/${condition}/${base}.png`,
    `imgs/${condition}/${base}.jpg`,
    `imgs/${condition}/${base}.jpeg`,
    `imgs/${condition}/${base}.webp`
  ];
}

function renderReferenceImage(imagePath) {
  return `
    <section class="reference-panel" id="reference-panel">
      <p class="reference-title"><strong>Reference image</strong> (same case for context)</p>
      <img
        id="reference-image"
        src="${escapeHtml(imagePath)}"
        alt="Reference image for this case"
        loading="lazy"
      />
      <p class="notice" id="reference-fallback" hidden>Reference image not available for this case.</p>
    </section>
  `;
}

function setupReferenceImageFallback(candidates) {
  const imageEl = document.getElementById("reference-image");
  const fallbackEl = document.getElementById("reference-fallback");
  const panelEl = document.getElementById("reference-panel");
  if (!imageEl || !fallbackEl || !panelEl) {
    return;
  }

  let idx = 0;
  imageEl.addEventListener("error", () => {
    idx += 1;
    if (idx < candidates.length) {
      imageEl.src = candidates[idx];
      return;
    }
    imageEl.hidden = true;
    fallbackEl.hidden = false;
  });
}

function scrollToTop() {
  window.scrollTo({
    top: 0,
    behavior: "smooth"
  });
}

function normalizeAnswerList(value) {
  if (Array.isArray(value)) {
    return value.slice();
  }
  if (!value) {
    return [];
  }
  return [value];
}

function computeNextValues(currentValues, changedValue, isChecked) {
  if (changedValue === "NONE") {
    return isChecked ? ["NONE"] : [];
  }

  const withoutNone = currentValues.filter((v) => v !== "NONE");
  if (isChecked) {
    if (!withoutNone.includes(changedValue)) {
      withoutNone.push(changedValue);
    }
  } else {
    return withoutNone.filter((v) => v !== changedValue);
  }
  return withoutNone;
}

function syncChoiceInputs(name, selectedValues) {
  const selected = new Set(selectedValues);
  const inputs = appEl.querySelectorAll(`input[name="${name}"]`);
  inputs.forEach((input) => {
    input.checked = selected.has(input.value);
  });
}

function renderArrowGuide(condition) {
  const singleConditionText = {
    wind:
      "<strong>Wind force:</strong> The arrow indicates the force direction, and its length indicates the force magnitude.",
    point:
      "<strong>Point force:</strong> The arrow indicates the force direction, and its length indicates the force magnitude. The circle around the starting point indicates the location of the local force.",
    wind_change:
      "<strong>Wind force change:</strong> The arrow indicates the force direction, and its length indicates the force magnitude. A change of the arrow means the global wind force has changed.",
    point_change:
      "<strong>Point force change:</strong> The arrow indicates the force direction, and its length indicates the force magnitude. The second force is applied to the same object, and is shown at the original position for reference.",
  };

  const guideBody = condition && singleConditionText[condition]
    ? `<ul><li>${singleConditionText[condition]}</li></ul>`
    : `
      <ul>
        <li><strong>Wind force:</strong> The arrow indicates the force direction, and its length indicates the force magnitude.</li>
        <li><strong>Point force:</strong> The arrow indicates the force direction, and its length indicates the force magnitude. The circle around the starting point indicates the location of the local force.</li>
        <li><strong>Wind force change:</strong> The arrow indicates the force direction, and its length indicates the force magnitude. A change of the arrow means the global wind force has changed.</li>
        <li><strong>Point force change:</strong> The arrow indicates the force direction, and its length indicates the force magnitude. The second force is applied to the same object, and is shown at the original position for reference.</li>
      </ul>
    `;

  return `
    <div class="arrow-guide">
      <p><strong>Arrow meaning guide</strong></p>
      ${guideBody}
    </div>
  `;
}

function shuffleArray(arr) {
  for (let i = arr.length - 1; i > 0; i -= 1) {
    const j = Math.floor(Math.random() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function humanCondition(condition) {
  switch (condition) {
    case "wind":
      return "Wind";
    case "point":
      return "Point";
    case "wind_change":
      return "Wind (Change)";
    case "point_change":
      return "Point (Change)";
    default:
      return condition;
  }
}

function escapeHtml(value) {
  return String(value)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/\"/g, "&quot;")
    .replace(/'/g, "&#39;");
}
